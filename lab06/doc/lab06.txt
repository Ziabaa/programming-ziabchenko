Лабораторна робота №6. Масиви

Зябченко Іван Володимирович, гр. КН-922а

Завдання: Дано двовимірний масив з N * N цілих чисел. Помножити матрицю саму на себе (відповідно
до правил множення матриць)

Основна частина:
- опис роботи основної функції: для того щоб помножити матрицю на матрицю потрібно, перемножити послідовно 
рядки першої маториці на кожнні стовпці другої матриці, при цьому кожний послідовний елемент повинен сумуватися. 
- перелік вхідних даних:
   - first_matrix[ROWS1][COLUMNS1] - перша матриця, позитивний цілий масив (int);
   - second_matrix[ROWS2][COLUMNS2] - друга матриця, позитивний цілий масив (int);
   - finaly_matrix[ROWS1][COLUMNS2] - результат, позитивний цілий масив (int).
- перелік констант: 
   - ROWS1 - кількість рядків першої матриці. Дорівнює значенню 3;
   - COLUMNS1 - кількість стовпців першої матриці. Дорівнює значенню 3;
   - ROWS2 - кількість рядків першої матриці. Дорівнює значенню 3;
   - COLUMNS2 - кількість стовпців першої матриці. Дорівнює значенню 3.
- дослідження результатів роботи програми:
	- finaly_matrix, знаходиться лише в тому випадку коли рядки першої матриці калькісно дорівнюють кількості
	  стовпців другої матриці, отже маємо умову, яка повинна виглядати таким чином:
			if (ROWS1 == COLUMNS2)
	- наступним кроком додаємо перший цикл який буде змінювати рядок першої матриці,тобто повинен бути не 
          більшим за кількість рядків першої матриці, крок встановлюємо на 1,повинно виглядати таким чином:
			 for (int i = 0; i < ROWS1; i++)
	- наступним кроком додаємо другий цикл в пешому, який буде змінювати стовпець першої матриці,тобто повинен бути не 
          більшим за кількість стовпців першої матриці, крок встановлюємо на 1,повинно виглядати таким чином:
			 for (int j = 0; j < COLUMNS2; j++)
	- наступним кроком додаємо третій цикл в другому, який буде змінювати стовпець та рядок другої та першої матриці 
          відповідно,тобто повинен бути не більшим за кількість стовпців та рядків першої та другої матриць, крок встановлюємо
          на 1,повинно виглядати таким чином:
			for (int k = 0; k < ROW1; k++)
	- Умова яка прописана в останньому циклі повинна додавати: нульовий стовпець і нульовий рядок першої матриці з нульовим 
          стовпцем і нульовим рядком другої матриці, перший стовпець і нульовий рядок першої матриці з нульовим стовпцем і першим
          рядком другої матриці, другий стовпець і нульовий рядок першої матриці з нульовим стовпцем і другим рядком другої матриці,
	  повинно виглядати таким чином:
			 finaly_matrix[i][j] += (first_matrix[i][k] * second_matrix[k][j]);
          -для підтвердження коректності роботи програми, зупинено відлагодник на строці з "return 0" та введемо команду 
          "print finaly_matrix". Після вводу команди отримали наступне:
		(lldb) print finaly_matrix
		(int[3][3]) finaly_matrix = {
 		[0] = ([0] = 26, [1] = 16, [2] = 33)
  		[1] = ([0] = 10, [1] = 14, [2] = 24)
  		[2] = ([0] = 20, [1] = 14, [2] = 28),
	Отже помилок немає, все вирішено вірно, і код працює вірно.

Структура проекту лабораторної роботи:
.
└── lab06
      ├── README.txt
      ├── doc
      |    └── lab06.txt
      ├── Makefile
      └── src
	   └── main.c

Висновки: при виконанні лабораторної роботи були набуті практичні навички створення масивів, та вивчено новий розділ: масиви. Також покращено
навички використання компілятора, та роботи з циклами та умовами в мові С.
